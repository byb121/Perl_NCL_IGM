#!/usr/bin/perl 
use strict;
use warnings;
use POSIX;
use Math::CDF qw(pbinom);
#use Statistics::Lite;

#################################################
### This script calculates information relating to the alignment to and coverage of target co-ordinates from alignment files generated by the program bowtie with the samtools option --sam specified
### Coverage information is calculated per target region instead of per base. This was done to reduce computational time and the subsequent size of files for loading into statistical packages and graph drawing
### It would be very straightforward to ammend the CalculateTargetCoverage subroutine to output all bases instead of calculating summary statistics as is currently done
### The script saves time and memory by not reading large files into the memory. In order for this to work all files must be in ascending order of alignment. This is done within the script for alignment files,
### however, all target files should be already in ascending order (I have a script for this too if you need it)
### this is a scipt created from Katherine Siddle's.
##################################################

#my $Targets = "TargetFiles/CCDSExonCoordinates_nonOV.txt"; # this should be comma separated and in ascending order. I also chose to combine overlapping targets.
#my ($dir) = @ARGV;
#my $lanes = "234";
my $currentdir = `pwd`;
chomp $currentdir;

opendir DIR, $currentdir or die "Cannot open directory";
my @thefiles= readdir(DIR);
@thefiles = sort @thefiles;
closedir(DIR);

my @PileupFiles;

my @GenoFiles = ('F08_272_s234_genodata.txt_on_Targets',
'F05_339_s56_genodata.txt_on_Targets',
'F05_232_s78_genodata.txt_on_Targets');
my $integratedGenoFile = InteGenoData(\@GenoFiles);
my $quality_cutoff = 15; 
my $cvrg_cutoff = 20;

my @coverage_columns;# 0-based numbers indecate positions of coverage recorded in the big table

foreach my $filename (@thefiles){
	if ($filename =~ /sam$/ ) {
		my $samfile = $currentdir."/".$filename;
  		print "$samfile\n";
  		my $indexedSortedBamFile = GetIndexedBamFile ($samfile);
  		my $pileupFile = GeneratePileupFile ($indexedSortedBamFile);
  		print $pileupFile." for ".$samfile." has been generated!\n";
  		push @PileupFiles, $pileupFile;
	}
}

#CalculateOnTargetReads ($samfile, $Targets); # this sub needs to be replaced. I could use my own modlules to do it.

my $number_of_pileup_file_processed = 0;

foreach my $file (@PileupFiles) {
	my $filtered_pileup_file = FilterPileupWithPositions($file,$integratedGenoFile);
	my $processed_filtered_pileup_file = PileupParser($filtered_pileup_file, $quality_cutoff, $cvrg_cutoff);
	Merge2FilesWithGenomePosition($integratedGenoFile, $processed_filtered_pileup_file);
	print "Merged $processed_filtered_pileup_file with $integratedGenoFile\n";
	$number_of_pileup_file_processed += 1;
	my $tmp = 8 + 5*($number_of_pileup_file_processed-1);
	push @coverage_columns, $tmp;
}

SummayTableAndCalculateSensiAndSpeci($integratedGenoFile, \@coverage_columns);
SummayTableAndCalculateSensiAndSpeciForSeqDataGenoTypingQuality($integratedGenoFile,\@coverage_columns);

exit;


#### Sub-routines #####


sub GetIndexedBamFile { # Uses samtools to generate indexed bam files from sam alignment outputs
	print "Warning: With this part of script the oringinal sam file will be removed after bam file is generated!\n";
	my ($samFile) = @_;     
	my $bamFile = $samFile.".bam";
	my $sortBamFile = $bamFile.".sorted";
	my $sortedBamFile = $sortBamFile.".bam";
    
    # Consider to handle samtools warnings in the future
    # For now there has to be enough disk space before running the script    
	`samtools view -bSu $samFile > $bamFile`;
	`rm $samFile`;
	`samtools sort $bamFile $sortBamFile`;
	`samtools index $sortedBamFile`;

	return($sortedBamFile);
}


sub GeneratePileupFile { # Uses the indexed bam file from GetIndexedBamFile to build a pileup file
        my ($sortedBamFile) = @_;
        my $pileupFile = $sortedBamFile.".pileup";

        `samtools pileup -f /home/data/yaobo/newBowtieAlignments/hg19.fa $sortedBamFile > $pileupFile`;

        return($pileupFile);
}

sub Merge2FilesWithGenomePosition {
	#the script will merge two tables in seperate file into the first file
	#first two columns as indentifier to map each row
	#N/A will be added to each column if the genome position is not found in the second file
	my ($file1, $file2) = @_;
	my %hash1;
	my %hash2;
	my $addedColumnNumber = 5;
	
	open FILE2, $file2 or die "Cannot open the file $file2";
	while (my $line = <FILE2>) {
		if ($line =~ m/^chr/) {
			chomp $line;
			my @splitLine = split(/\t/, $line);
			my $chrom = $splitLine[0]; chomp $chrom;
			my $pos =  $splitLine[1]; chomp $pos;
			if(!exists($hash2{$chrom."_".$pos})){
				for (my $i=2; $i<scalar @splitLine; $i++){
					if($i==2){
						$hash2{$chrom."_".$pos}= $splitLine[$i];
					} else {
						$hash2{$chrom."_".$pos} = $hash2{$chrom."_".$pos}."\t".$splitLine[$i];
					}
				}			
			} else {
				print "Warning: Found duplicate entry in $file2 on position $chrom $pos\tAction: Removed!!\n";
			}
			
		}
	}
	close FILE2;

	my @output;
	open FILE1, $file1 or die "Cannot open the file $file1";
	my $line_number = 0;	
	while (my $line = <FILE1>) {
		$line_number += 1;
		if ($line =~ m/^chr/) {
			chomp $line;
			my @splitLine = split(/\t/, $line);
			my $chrom = $splitLine[0]; chomp $chrom;
			my $pos =  $splitLine[1]; chomp $pos;
			if(!exists($hash1{$chrom."_".$pos})){
				$hash1{$chrom."_".$pos} = 0;
				if(exists($hash2{$chrom."_".$pos})) {
					my @temp_array = split(/\t/,$hash2{$chrom."_".$pos});
					if(scalar @temp_array == 5){
						#print "scalar @temp_array == 5       at $line_number.\n";
						push @output, $line."\t".$hash2{$chrom."_".$pos}."\n";
					} else {
						my $x = scalar @temp_array;
						print $x."\n";
						foreach my $value (@temp_array) {
							print $value."\n";
						}
						#print "scalar @temp_array <= 5       at $line_number.\n";
						my $temp_string;
						for (my $i=scalar @temp_array + 1; $i<=$addedColumnNumber; $i++){
							if ($i == scalar @temp_array + 1) {
								$temp_string = "N/A";
							} else {
								$temp_string = $temp_string."\t"."N/A"; 
							}
						}
						push @output, $line."\t".$hash2{$chrom."_".$pos}."\t".$temp_string."\n";
					}
				} else {
					#print "scalar temp_array == 0       at $line_number.\n";
					my $temp_string ="";
					for (my $i=1; $i<=$addedColumnNumber; $i++){
						$temp_string = $temp_string."\t"."N/A"; 
					}
					push @output, $line.$temp_string."\n";
				}
			} else {
				print "Warning: Found duplicate entry in $file1 on position $chrom $pos\tAction: Removed!!\n";
			}
		}
	}
	close FILE1;
	
	open OUTPUT, ">$file1" or die "Cannot open the file $file1 to write";
	print OUTPUT @output;
	close OUTPUT;
}

sub InteGenoData{
	my ($files) = @_;
	my @GenoFiles = @$files;
	my %GenoHash;
	foreach my $file (@GenoFiles) {
		print "reading data from file $file.....\n";
		open GENO, $file or die "Cannot open the file $file";
		while (my $line = <GENO>) {
			if ($line =~ m/^chr/) {
				chomp $line;
				my @splitLine = split(/\t/, $line);
				my $chrom = $splitLine[0]; chomp $chrom;
				my $pos =  $splitLine[1]; chomp $pos;
				my @alleles = split(/\//, $splitLine[2]);
				if(!exists($GenoHash{$chrom."_".$pos})){
					$GenoHash{$chrom."_".$pos} = $alleles[0]."\t".$alleles[1]."\t".$splitLine[3];			
				}
			}
		}
		close(GENO);
		print "done!\n";
	}

	#To add pheno data of each patient
	my $i = 0;
	foreach my $file (@GenoFiles) {
		open GENO, $file or die "Cannot open the file $file";
		$i += 1;
		print "reading phenotype data from file $file for patient $i.....\n";
		my %temp_hash;
		while (my $line = <GENO>) {
			if ($line =~ m/^chr/) {
				chomp $line;
				my @splitLine = split(/\t/, $line);
				my $chrom = $splitLine[0]; chomp $chrom;
				my $pos =  $splitLine[1]; chomp $pos;
				$temp_hash{$chrom."_".$pos} = $splitLine[4];
			}
		}
		close GENO;
	
		foreach my $key (keys %GenoHash) {
			if(exists $temp_hash{$key}){
				$GenoHash{$key} = $GenoHash{$key}."\t".$temp_hash{$key};
			}else{
				$GenoHash{$key} = $GenoHash{$key}."\t"."no call";
			}
		}
	}
	my $CurrentDir=`pwd`;
	chomp $CurrentDir;
	my $output_file = $CurrentDir."/"."Integrated_Geno_File_of".$i."_patients.txt";

	open OUTPUT, ">$output_file" or die "Cannot open the file $output_file";	
	foreach my $key (keys %GenoHash) {
		my @seperate_key = split("_", $key);
		print OUTPUT $seperate_key[0]."\t".$seperate_key[1]."\t";
		print OUTPUT $GenoHash{$key}."\n";
	}
	close OUTPUT;	
	return $output_file;
}

sub FilterPileupWithPositions{
	my($PileupFile,$GenoFile) = @_;
	my %positionsHash;
	open InputPositions, $GenoFile or die "Cannot open $GenoFile";
	while (my $line = <InputPositions>) {
		chomp $line;
		#print $line."\n";
		if ($line =~ m/^chr/) {
			my @splitLine = split(/\s+/, $line);
			my $chrom = $splitLine[0]; chomp $chrom;
			my $pos =  $splitLine[1]; chomp $pos;
			$positionsHash{$chrom."_".$pos} = 0;
		}
	}
	close(InputPositions);
	my @output;
	
	open PILEUP, $PileupFile or die "Cannot open $PileupFile";
	while (my $line=<PILEUP>) {
		chomp $line;
		if ($line =~ m/chr/) {
			my @splitLine = split(/\s+/, $line);
			my $chrom = $splitLine[0];
			my $pos = $splitLine[1];
			if(exists $positionsHash{$chrom."_".$pos}){
				push @output, $line."\n";
			} 
		}
	}
	close(PILEUP);
	#ouput to file
    my $OutputFile = $PileupFile."_on_GenoChipPositions";
    open OUTPUT, ">$OutputFile" or die "Cannot create $OutputFile";
    print OUTPUT @output;
    close OUTPUT;
    return ($OutputFile);
}

sub PileupParser {
	#modified from the script on the webpage 
	#https://bitbucket.org/galaxy/galaxy-central/src/tip/tools/samtools/pileup_parser.pl
	#die "Usage: pileup_parser.pl <in_file> <qv cutoff> <coverage cutoff> <out_file>\n" unless @ARGV == 4;

	#my $in_file = $ARGV[0];
	#my $quality_cutoff = $ARGV[1]; # phred scale integer
	#my $cvrg_cutoff = $ARGV[2]; # unsigned integer
	#my $out_file = $ARGV[3];
	
	my ($in_file,$quality_cutoff, $cvrg_cutoff) = @_;
	my $out_file = $in_file."_parsed";
	my $ref_base_column = 2; # 0 based
	my $read_bases_column = 4; # 0 based
	my $base_quality_column = 5; # 0 based
	my $cvrg_column = 3; # 0 based
	my $SNPs_only = "NO"; # set to "Yes" to print only positions with SNPs; set to "No" to pring everything
	my $bed = "NO"; #set to "Yes" to convert coordinates to bed format (0-based start, 1-based end); set to "No" to leave as is
	my $coord_column = 1; #0 based 
	my $total_diff = "Yes"; # set to "Yes" to print total number of deviant based
	my $print_qual_bases = "Yes"; #set to "Yes" to print quality and read base columns
	my $invalid_line_counter = 0;
	my $first_skipped_line = "";
	my %SNPs = ('A',0,'T',0,'C',0,'G',0);
	my $above_qv_bases = 0;
	my $SNPs_exist = 0;
	my $out_string = "";
	my $diff_count = 0;
	
	open (IN, "<$in_file") or die "Cannot open $in_file $!\n";
	open (OUT, ">$out_file") or die "Cannot open $out_file $!\n";
	
	while (<IN>) {
		chop;
		next if m/^\#/;
		my @fields = split /\t/;
		next if $fields[ $ref_base_column ] eq "*"; # skip indel lines
		my $read_bases   = $fields[ $read_bases_column ];
		die "Coverage column" . ($cvrg_column+1) . " contains non-numeric values. Check your input parameters as well as format of input dataset." if ( not isdigit $fields[ $cvrg_column ] );
		next if $fields[ $cvrg_column ] < $cvrg_cutoff;
		my $base_quality = $fields[ $base_quality_column ];
		if ($read_bases =~ m/[\$\^\+-]/) {
			$read_bases =~ s/\^.//g; #removing the start of the read segement mark
			$read_bases =~ s/\$//g; #removing end of the read segment mark
			while ($read_bases =~ m/[\+-]{1}(\d+)/g) {
				my $indel_len = $1;
				$read_bases =~ s/[\+-]{1}$indel_len.{$indel_len}//; # remove indel info from read base field
			}
		}
		if ( length($read_bases) != length($base_quality) ) {
			$first_skipped_line = $. if $first_skipped_line eq "";
	        ++$invalid_line_counter;
	        next;
		}
		# after removing read block and indel data the length of read_base 
		# field should identical to the length of base_quality field
		
		my @bases = split //, $read_bases;
		my @qv    = split //, $base_quality;
		for my $base ( 0 .. @bases - 1 ) {
			if ( ord( $qv[ $base ] ) - 33 >= $quality_cutoff and $bases[ $base ] ne '*'){
				++$above_qv_bases;
				if ( $bases[ $base ] =~ m/[ATGC]/i ){
					$SNPs_exist = 1; 
					$SNPs{ uc( $bases[ $base ] ) } += 1;
					$diff_count += 1;
				} elsif ( $bases[ $base ] =~ m/[\.,]/ ) {
					$SNPs{ uc( $fields[ $ref_base_column ] ) } += 1;
				}
			}
		}
		
		my $ref_count = 0;
		
		my $out_string = $fields[0]."\t".$fields[$coord_column]."\t".$above_qv_bases."/".$fields[$cvrg_column]."\t".$fields[$ref_base_column]."/".$SNPs{uc($fields[ $ref_base_column])};
		foreach my $key (keys %SNPs){
			if ($key ne uc($fields[$ref_base_column]) and $SNPs{$key} > 0) {
				$out_string = $out_string."\t".$key."/".$SNPs{$key};
			}
		}
		print OUT $out_string."\n";
		
		$above_qv_bases = 0;
		%SNPs = ('A',0,'T',0,'C',0,'G',0);
	}
	

	print "Skipped $invalid_line_counter invalid line(s) beginning with line $first_skipped_line\n" if $invalid_line_counter > 0;
	close IN;
	close OUT;
	return ($out_file);
}


# the sub only works for 3 patients geno chip data
# @geno_homo_hetero has to be adjusted accordingly to the number of seq data sets in comparison
# the sub calculates the sensitivity and specificity for variants detection of sequencing data
sub SummayTableAndCalculateSensiAndSpeci {
	##########################################################
	###### The script will also calculate the sensitivity and specificity of 
	###### variant detection of sequencing data based on the geno chip data
	###### eg: geno chip data is considered as reality
	###### 			Scheme			
	######        Ref	Var	TP	TN	FP	FN
	###### Chip	+	+	Yes			
	###### Seq	-	+				
	###### Chip	+	+				Yes
	###### Seq	+	-				
	###### Chip	+	+	Yes			
	###### Seq	+	+				
	###### Chip	-	+	Yes			
	###### Seq	-	+				
	###### Chip	-	+				Yes
	###### Seq	+	-				
	###### Chip	-	+	Yes			
	###### Seq	+	+				
	###### Chip	+	-			Yes	
	###### Seq	-	+				
	###### Chip	+	-		Yes		
	###### Seq	+	-				
	###### Chip	+	-			Yes	
	###### Seq	+	+										
	###### Chip	+	+				Yes
	###### Seq	-	-				
	###### Chip	+	-		Yes		
	###### Seq	-	-				
	###### Chip	-	+				Yes
	###### Seq	-	-				
	###### "no call" is considered invalid value
	###### When both allele A and allele B are related to ref base
	###### the one equals ref represents the ref base
	###### the other on represents the var base
	##########################################################
	
	
	#my $input_file = "Integrated_Geno_File_of3_patients.txt";
	#my $input_file = "testfile.txt";
	
	my ($input_file, $column_array_ref) = @_;
	my @output;
	my $output_file = $input_file."_summarized";
	my @coverage_positions = @$column_array_ref;
	
	my @true_positives;
	my @true_negatives;
	my @false_positives;
	my @false_negatives;
	
	for(my $i = 0; $i<@coverage_positions; $i++){
		push @true_positives, 0;
		push @true_negatives, 0;
		push @false_positives, 0;
		push @false_negatives, 0; 
	}
	
	open OUTPUT, ">$output_file" or die "Cannot open the file $output_file.";

	open INPUT, $input_file or die "Cannot open the file $input_file.";
	while (my $line = <INPUT>) {
		chomp $line;
		my @fields = split(/\t/,$line);
		my $chr = $fields[0];
		my $coor = $fields[1];
		my $g_a = $fields[2];
		my $g_b = $fields[3];
		my @geno_homo_hetero = ($fields[5],$fields[5],$fields[5],$fields[5],$fields[5],$fields[5],$fields[5],$fields[6],$fields[6],$fields[6],$fields[7],$fields[7],$fields[7]);
		my @seq_homo_hetero;
		my @most_covered_bases; #array of hashes
		my @total_coverage;
		my $ref;
		my $var;
		my $a_ref;
		my $b_ref;
		my $a_var;
		my $b_var;
		my $output_string;
		
		foreach my $coverage_position (@coverage_positions){
			my $ref_position = $coverage_position + 1;
			if ($fields[$ref_position] ne "N/A" && !$ref){
				my @ref_temp = split(/\//, $fields[$ref_position]);
				$ref = $ref_temp[0];
			}
		}
		
		if (!$ref){
			$output_string = $chr."\t".$coor."\t".$g_a."\t".$g_b."\t"."No sufficient coverage";
			for(my $i = 0; $i<@coverage_positions; $i++){
				$output_string = $output_string."\t"."No sufficient coverage";
			}
			next;
		}
		## lines(SNPs)with no sufficient sequencing data coverage on the position will be removed from the SNP file.
		
		$ref = uc($ref);
	
		my $c_ref =  ComplementaryBase($ref); 
		
		$output_string =  $chr."\t".$coor."\t".$g_a."\t".$g_b."\t".$ref;
		
		#to assign the total coverage values
		foreach my $coverage_position (@coverage_positions){
			if ($fields[$coverage_position] ne "N/A") {
				my @coverage_numbers = split (/\//, $fields[$coverage_position]);
				push @total_coverage, $coverage_numbers[0];
			}else{
				push @total_coverage,0;
			}
				
		}
		
		#to read in two most covered based on that posions for patients
		my $patient_number = 0;
		
		foreach my $coverage_position (@coverage_positions){
			my $temp_hash = {};
			for (my $i = $coverage_position + 1; $i<= $coverage_position + 4; $i++) {
				if ($fields[$i] ne "N/A") {
					my @tmp = split (/\//, $fields[$i]);
					$temp_hash->{uc($tmp[0])} = $tmp[1];
				}
			}
			
			$patient_number += 1; 
			
			if (scalar(keys %$temp_hash)  == 0) {
				print "$chr $coor: $patient_number No sufficient coverage to define any base. \n";
				push @most_covered_bases, $temp_hash;
			} elsif (scalar(keys %$temp_hash) >0 && scalar(keys %$temp_hash) <=2) {
				push @most_covered_bases, $temp_hash;
			} else {
				my @sorted = sort {$temp_hash->{$b} <=> $temp_hash->{$a}} keys %$temp_hash; 
				my $temp_hash_2 = {};
				$temp_hash_2->{$sorted[0]} = $temp_hash->{$sorted[0]}; 
				$temp_hash_2->{$sorted[1]} = $temp_hash->{$sorted[1]};
				push @most_covered_bases, $temp_hash_2;
			}
		}
		
		#determine homo/heter zygous type from the sequencing data
		for(my $i =0 ; $i <@coverage_positions; $i++) {
			if ($total_coverage[$i] == 0 ) {
				push @seq_homo_hetero, "N/A";
			} elsif ( keys %{$most_covered_bases[$i]} == 0) {
				push @seq_homo_hetero, "N/A";
			} elsif ($total_coverage[$i] > 0 && keys %{$most_covered_bases[$i]} > 0) {
				my %new_temp_hash;
				foreach my $key (keys %{$most_covered_bases[$i]}){
					#print "pbinom x is $most_covered_bases[$i]{$key}\n";
					#print "pbinom total is $total_coverage[$i]\n";
					if (pbinom($most_covered_bases[$i]{$key}, $total_coverage[$i], 0.05) > 0.95) {
						$new_temp_hash{$key} = $most_covered_bases[$i]{$key};
					}
				}
				
				$most_covered_bases[$i] = \%new_temp_hash;
				
				my %new_temp_hash_2 = %new_temp_hash;
				if(keys %new_temp_hash_2 == 0) {
					push @seq_homo_hetero, "N/A";
				} elsif (keys %new_temp_hash_2 == 1) {
					if(exists $new_temp_hash_2{$ref} || exists $new_temp_hash_2{$c_ref}) {
						push @seq_homo_hetero, "RR";
					}else {
						push @seq_homo_hetero, "VV";
					}
				} elsif (keys %new_temp_hash_2 == 2) {
					if(exists $new_temp_hash_2{$ref} || exists $new_temp_hash_2{$c_ref}) {
						if (exists $new_temp_hash_2{$ref}) {
							delete $new_temp_hash_2{$ref};
						}else {
							delete $new_temp_hash_2{$c_ref};
						}
						
						if(exists $new_temp_hash_2{$ref} || exists $new_temp_hash_2{$c_ref}) {
							push @seq_homo_hetero, "RR";
						} else {
							push @seq_homo_hetero, "RV";
						}
					} else {
						my @keys = keys %new_temp_hash_2;
						if ($keys[0] ne ComplementaryBase($keys[1])) {
							push @seq_homo_hetero, "RV";
							print "$chr $coor: possible error for reference base at postion.\n";
						}else {
							push @seq_homo_hetero, "VV";
						}
					}
				} else {
					print "$chr $coor :";
					print "new_temp_hash has invalid elements number:";
					print keys %new_temp_hash_2;
					print "\n";
				}
			}
		}
	
		#compare A B bases to ref
		
		if (CompareAwithB($g_a,$ref) eq "No Match"){
			$a_ref = "N/A";
		} else {
			if (CompareAwithB($g_a,$ref) eq "A=B") {
				$a_ref = "A=Ref";
			}else {
				$a_ref = "A=C_Ref";
			}	
		}	
	 	
	 	if (CompareAwithB($g_b,$ref) eq "No Match"){
			$b_ref = "N/A";
		} else {
			if (CompareAwithB($g_b,$ref) eq "A=B") {
				$b_ref = "B=Ref";
			}else {
				$b_ref = "B=C_Ref";
			}	
		}
		
		if (CompareAwithB($g_b,$ref) eq "No Match" && CompareAwithB($g_a,$ref) eq "No Match"){
			print "$chr $coor: What a Ref!!!!!\n";
		}
		
		######################################
		##### determine if the geno chip data is consistant with sequencing data
		###########################################################################
		##### and determine number of true positives, true negatives
		##### ,false positives and false negatives (take geno chip data as reality).
		##### This is used calculate the sensitivity and specificity of Sequencing data to detect variants
		######################################
		
	
		
		for(my $i =0 ; $i <@coverage_positions; $i++) {
			
			if ($geno_homo_hetero[$i] eq "no call"  || keys %{$most_covered_bases[$i]} == 0 ){ 
			# if nocall in genotyping data for the patient or there's no base is confirmed on the position from the seqencing data
				if ($geno_homo_hetero[$i] eq "no call" ) {
					$output_string = $output_string."\t"."no call";
				} else {
					$output_string = $output_string."\t"."No sufficient coverage";
					############################## 17/02/2011 ########################
					##### To handle no coverage but have calls on geno chip
					##### To determine true/false negatives ################
					if ($a_ref ne "N/A" && $b_ref eq "N/A" ) {
						if ($geno_homo_hetero[$i] eq "AA"){
							$true_negatives[$i] += 1;
						} else {#AB, BB
							$false_negatives[$i] += 1;
						}
					} elsif ( $a_ref eq "N/A" && $b_ref ne "N/A" ){
						if  ($geno_homo_hetero[$i] eq "BB") {
							$true_negatives[$i] += 1;
						} else { #AA, AB
							$false_negatives[$i] += 1;
						}
					} else { 
						if ($a_ref  eq "A=Ref") {
							if ($geno_homo_hetero[$i] eq "AA") {
								$true_negatives[$i] += 1;
							} else {
								$false_negatives[$i] += 1;
							}
						} elsif ($b_ref  eq "B=Ref") {
							if ($geno_homo_hetero[$i] eq "BB") {
								$true_negatives[$i] += 1;
							} else {
								$false_negatives[$i] += 1;
							}
						}else{
							# if both Allele A and Allele B are NON related to ref or complemtary ref
							$false_negatives[$i] += 1;
						}
					}
					################################# 17/02/2011 #############################################
				}
				next;
			} elsif (keys %{$most_covered_bases[$i]} == 1) {
			# if one base is confirmed on the position from the seqencing data
				if ($geno_homo_hetero[$i] eq "AA" || $geno_homo_hetero[$i] eq "BB"  ) {
				#geno typing data situations
					if ($a_ref ne "N/A" && $b_ref eq "N/A" ) { 
					# if Allele A is equal to ref or complemtary ref
						if ($geno_homo_hetero[$i] eq "AA") { # AA 
							if ($a_ref  eq "A=Ref"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$output_string = $output_string."\t"."Consistent";
									$true_negatives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									 $false_positives[$i] += 1;
								}
							} else {
								if (exists $most_covered_bases[$i]{ComplementaryBase($g_a)}) {
									$output_string = $output_string."\t"."Consistent";
									$true_negatives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									$false_positives[$i] += 1;
								}
							}
						} else { #BB
							if ($a_ref  eq "A=Ref") {
								if (exists $most_covered_bases[$i]{$g_b}) {
									$output_string = $output_string."\t"."Consistent";
									$true_positives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if (exists $most_covered_bases[$i]{$g_a}) {
										$false_negatives[$i] += 1;
									} else {
										$false_positives[$i] += 1;
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ ComplementaryBase($g_b)}) {
									$output_string = $output_string."\t"."Consistent";
									$true_positives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if (exists $most_covered_bases[$i]{ComplementaryBase($g_a)}) {
										$false_negatives[$i] += 1;
									} else {
										$false_positives[$i] += 1;
									}
								}
							}
						}
					} elsif ($a_ref eq "N/A" && $b_ref ne "N/A" ) {
					# if Allele B is equal to ref or complemtary ref
						if  ($geno_homo_hetero[$i] eq "AA") { #AA
							if ($b_ref  eq "B=Ref"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$output_string = $output_string."\t"."Consistent";
									$true_positives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if (exists $most_covered_bases[$i]{$g_b}) {
										$false_negatives[$i] += 1;
									} else {
										$false_positives[$i] += 1;
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ ComplementaryBase($g_a)}) {
									$output_string = $output_string."\t"."Consistent";
									$true_positives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if (exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
										$false_negatives[$i] += 1;
									} else {
										$false_positives[$i] += 1;
									}
								}
							}
						} else { #BB
							if ($b_ref  eq "B=Ref"){
								if (exists $most_covered_bases[$i]{$g_b}) {
									$output_string = $output_string."\t"."Consistent";
									$true_negatives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									$false_positives[$i] += 1;
								}
							} else {
								if (exists $most_covered_bases[$i]{ ComplementaryBase($g_b)}) {
									$output_string = $output_string."\t"."Consistent";
									$true_negatives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									$false_positives[$i] += 1;
								}
							}
						}					
					} else { #Either Allele A or Allele B is either equal or complementary to ref
					#treat Allele A and Allele B are non related, one stands for Ref and the other one stands for Var
						if($a_ref eq "A=Ref"){
							if  ($geno_homo_hetero[$i] eq "AA"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$output_string = $output_string."\t"."Consistent";
									$true_negatives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									$false_positives[$i] += 1;
								}
							} else {#BB
								if (exists $most_covered_bases[$i]{$g_b}) {
									$output_string = $output_string."\t"."Consistent";
									$true_positives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if(exists $most_covered_bases[$i]{$g_a}){
										$false_negatives[$i] += 1;
									} else {
										$false_positives[$i] += 1;
									}
								}
							}
						}elsif($b_ref eq "B=Ref"){
							if  ($geno_homo_hetero[$i] eq "AA"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$output_string = $output_string."\t"."Consistent";
									$true_positives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if(exists $most_covered_bases[$i]{$g_b}){
										$false_negatives[$i] += 1;
									} else {
										$false_positives[$i] += 1;
									}
								}
							} else {#BB
								if (exists $most_covered_bases[$i]{$g_b}) {
									$output_string = $output_string."\t"."Consistent";
									$true_negatives[$i] += 1;
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									$false_positives[$i] += 1;
								}
							}
						} else {
							##########################################################################
							# if both Allele A and Allele B  are NON related to ref or complemtary ref
							#rare but possible
							##but this does not necessrayly mean that var from sequencing data is not confirmed by chip data
							###require further code here. It's not right to treat the situation as N/A
							###########################################################################
							###########################################################################
							#changed code - 16/02/2011
							if(exists $most_covered_bases[$i]{$ref} ) {
								$output_string = $output_string."\t"."Inconsistent";
								$false_negatives[$i] += 1;
							} else {
								if ($most_covered_bases[$i]{$g_a} && $geno_homo_hetero[$i] eq "AA"){
									$output_string = $output_string."\t"."Consistent";
									$true_positives[$i] += 1;
								}elsif($most_covered_bases[$i]{$g_b} && $geno_homo_hetero[$i] eq "BB"){
									$output_string = $output_string."\t"."Consistent";
									$true_positives[$i] += 1;
								}else{
									$output_string = $output_string."\t"."Inconsistent";
									$false_positives[$i] += 1;
								}
							}
						}
					}
				} else { # "AB" appears on geno chip
					$output_string = $output_string."\t"."Inconsistent";
					if ($a_ref ne "N/A" && $b_ref eq "N/A" ){
						if ($a_ref  eq "A=Ref") {
							if (exists $most_covered_bases[$i]{$g_b}) {
								$true_positives[$i] += 1;
							} else{
								if (exists $most_covered_bases[$i]{$ref}) {
									$false_negatives[$i] += 1;
								} else {
									$false_positives[$i] += 1;
								}
							}
						} else {
							if (exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
								$true_positives[$i] += 1;
							} else{
								if (exists $most_covered_bases[$i]{$ref}) {
									$false_negatives[$i] += 1;
								} else {
									$false_positives[$i] += 1;
								}
							}
						}
					} elsif ($b_ref ne "N/A" && $a_ref eq "N/A") {
						if ($b_ref  eq "B=Ref") {
							if (exists $most_covered_bases[$i]{$g_a}) {
								$true_positives[$i] += 1;
							} else{
								if (exists $most_covered_bases[$i]{$ref}) {
									$false_negatives[$i] += 1;
								} else {
									$false_positives[$i] += 1;
								}
							}
						} else {
							if (exists $most_covered_bases[$i]{ComplementaryBase($g_a)}) {
								$true_positives[$i] += 1;
							} else{
								if (exists $most_covered_bases[$i]{$ref}) {
									$false_negatives[$i] += 1;
								} else {
									$false_positives[$i] += 1;
								}
							}
						}
					} else {
						if($a_ref ne "N/A"){
							if (exists $most_covered_bases[$i]{$ref} || exists $most_covered_bases[$i]{ComplementaryBase($ref)} ){
								$true_negatives[$i] += 1;
							} else {
								$false_positives[$i] += 1;
							}
						}else {
							if (exists $most_covered_bases[$i]{$ref} || exists $most_covered_bases[$i]{ComplementaryBase($ref)} ){
								$false_negatives[$i] += 1;
							}elsif (exists $most_covered_bases[$i]{$g_a} || exists $most_covered_bases[$i]{$g_b} ){
								$true_positives[$i] += 1;
							} else {
								$false_positives[$i] += 1;
							}
						}
					}
				}
			} elsif (keys %{$most_covered_bases[$i]} == 2) {
				if ($geno_homo_hetero[$i] eq "AB") {
					if($a_ref ne "N/A" && $b_ref eq "N/A" ){
						if($a_ref  eq "A=Ref"){
							if(exists $most_covered_bases[$i]{$g_a} && exists $most_covered_bases[$i]{$g_b}) {
								$output_string = $output_string."\t"."Consistent";
								$true_positives[$i] += 1;
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{$g_a} ||  exists $most_covered_bases[$i]{$g_b}) {
									if(exists $most_covered_bases[$i]{$g_a}){
										$false_positives[$i] += 1;
									}else{
										$true_positives[$i] += 1;
									}
								}else{
									$false_positives[$i] += 1;
								}
							}
						} else {
							if(exists $most_covered_bases[$i]{ComplementaryBase($g_a)} && exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
								$output_string = $output_string."\t"."Consistent";
								$true_positives[$i] += 1;
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{ComplementaryBase($g_a)} ||  exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
									if(exists $most_covered_bases[$i]{ComplementaryBase($g_a)}){
										$false_positives[$i] += 1;
									}else{
										$true_positives[$i] += 1;
									}
								} else {
									$false_positives[$i] += 1;
								}
							}
						}
					} elsif ($a_ref eq "N/A" && $b_ref ne "N/A" ) {
						if($b_ref  eq "B=Ref"){
							if(exists $most_covered_bases[$i]{$g_a} && exists $most_covered_bases[$i]{$g_b}) {
								$output_string = $output_string."\t"."Consistent";
								$true_positives[$i] += 1;
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{$g_a} ||  exists $most_covered_bases[$i]{$g_b}) {
									if(exists $most_covered_bases[$i]{$g_b}){
										$false_positives[$i] += 1;
									} else{
										$true_positives[$i] += 1;
									}
								} else {
									$false_positives[$i] += 1;
								}
							}
						} else {
							if(exists $most_covered_bases[$i]{ComplementaryBase($g_a)} && exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
								$output_string = $output_string."\t"."Consistent";
								$true_positives[$i] += 1;
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{ComplementaryBase($g_a)} ||  exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
									if(exists $most_covered_bases[$i]{ComplementaryBase($g_b)}){
										$false_positives[$i] += 1;
									} else{
										$true_positives[$i] += 1;
									}
								} else {
									$false_positives[$i] += 1;
								}
							}
						}
					}else {
						if($a_ref eq "A=Ref"){
							if(exists $most_covered_bases[$i]{$g_a} && exists $most_covered_bases[$i]{$g_b}) {
								$output_string = $output_string."\t"."Consistent";
								$true_positives[$i] += 1;
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{$g_a} ||  exists $most_covered_bases[$i]{$g_b}) {
									if(exists $most_covered_bases[$i]{$g_a}){
										$false_positives[$i] += 1;
									} else{
										$true_positives[$i] += 1;
									}
								} else {
									$false_positives[$i] += 1;
								}
							}
						}elsif($b_ref eq "B=Ref"){
							if(exists $most_covered_bases[$i]{$g_a} && exists $most_covered_bases[$i]{$g_b}) {
								$output_string = $output_string."\t"."Consistent";
								$true_positives[$i] += 1;
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{$g_a} ||  exists $most_covered_bases[$i]{$g_b}) {
									if(exists $most_covered_bases[$i]{$g_b}){
										$false_positives[$i] += 1;
									} else{
										$true_positives[$i] += 1;
									}
								} else {
									$false_positives[$i] += 1;
								}
							}
						} else {
							# if both Allele A and Allele B  are NON related to ref or complemtary ref
							#rare but possible
							$output_string = $output_string."\t"."N/A2222";
							############################### 17/02/2011 ################################# Done here ###############
	
							if ( exists $most_covered_bases[$i]{$g_a} &&  exists $most_covered_bases[$i]{$g_b}) {
								$true_positives[$i] += 1;
							} else {
								$false_positives[$i] += 1;
							}
							############################### 17/02/2011 ################################# Done here ###############
						}
					}				
				} else {
					$output_string = $output_string."\t"."Inconsistent";
					
					######################################################################
					######################################################################
					####   hard bit											 #############
					######################################################################
					######################################################################
					
					if ($a_ref ne "N/A" && $b_ref eq "N/A" ) {
						if ($geno_homo_hetero[$i] eq "AA"){
							$false_positives[$i] += 1;
						} else {#BB
							if ($a_ref  eq "A=Ref") {
								if (exists $most_covered_bases[$i]{$g_b}) {
									$true_positives[$i] += 1;
								}else{
									$false_positives[$i] += 1;
								}
							} else {
								if (exists $most_covered_bases[$i]{ ComplementaryBase($g_b)}) {
									$true_positives[$i] += 1;
								} else {
									$false_positives[$i] += 1;
								}
							}
						}
					} elsif ( $a_ref eq "N/A" && $b_ref ne "N/A" ){
						if  ($geno_homo_hetero[$i] eq "AA") { #AA
							if ($b_ref  eq "B=Ref"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$true_positives[$i] += 1;
								}else{
									$false_positives[$i] += 1;
								}
							} else {
								if (exists $most_covered_bases[$i]{ ComplementaryBase($g_a)}) {
									$true_positives[$i] += 1;
								}else{
									$false_positives[$i] += 1;
								}
							}
						} else { #BB
							$false_positives[$i] += 1;
						}
					} else { # if both Allele A and Allele B are NON related to ref or complemtary ref
						if ($a_ref  eq "A=Ref") {
							if ($geno_homo_hetero[$i] eq "AA") {
								$false_positives[$i] += 1;
							} else {
								if (exists $most_covered_bases[$i]{$g_b}) {
									$true_positives[$i] += 1;
								}else{
									$false_positives[$i] += 1;
								}
							}
						} elsif ($b_ref  eq "B=Ref") {
							if ($geno_homo_hetero[$i] eq "BB") {
								$false_positives[$i] += 1;
							} else {
								if (exists $most_covered_bases[$i]{$g_a}) {
									$true_positives[$i] += 1;
								}else{
									$false_positives[$i] += 1;
								}
							}
						}elsif( exists $most_covered_bases[$i]{$g_a} || exists $most_covered_bases[$i]{$g_b}) {
							$true_positives[$i] += 1;
						} else {
							$false_positives[$i] += 1;
						}
					}
				}
			}
		}
		print OUTPUT $output_string."\n";
	}
	
	close INPUT;
	close OUTPUT;
	
	for(my $j =0 ; $j <@coverage_positions; $j++) {
		print "For patient $j :\n";
		print "\tTrue Positives = ";
		print $true_positives[$j];
		print "\n";
		print "\tFalse Positives = ";
		print $false_positives[$j];
		print "\n";
		print "\tTrue Negatives = ";
		print $true_negatives[$j];
		print "\n";
		print "\tFalse Negatives = ";
		print $false_negatives[$j];
		print "\n";
		print "\n";
		print "\tSensitivity of Exome sequencing is ";
		print $true_positives[$j]/($true_positives[$j] + $false_negatives[$j]);
		print "\n";
		print "\tSpecificity is ";
		print $true_negatives[$j]/($true_negatives[$j] + $false_positives[$j]);
		print "\n";
		print "\tFalse Discovery Rate is ";
		print $false_positives[$j]/($true_positives[$j] + $false_positives[$j]);
		print "\n";
		print "\n";
		print "\n";
	}
	
}

#the sub only works for 3 patients geno chip data
#the sub calculates the sensitivity and specificity for Genotyping quality in autosomes
sub SummayTableAndCalculateSensiAndSpeciForSeqDataGenoTypingQuality {
	my ($input_file, $column_array_ref) = @_;
	my @output;
	my $output_file = $input_file."_summarized";
	my @coverage_positions = @$column_array_ref;
	
	my @true_positives;
	my @true_negatives;
	my @false_positives;
	my @false_negatives;
	
	for(my $i = 0; $i<@coverage_positions; $i++){
		push @true_positives, 0;
		push @true_negatives, 0;
		push @false_positives, 0;
		push @false_negatives, 0; 
	}
	
	open OUTPUT, ">$output_file" or die "Cannot open the file $output_file.";

	open INPUT, $input_file or die "Cannot open the file $input_file.";
	while (my $line = <INPUT>) {
		chomp $line;
		my @fields = split(/\t/,$line);
		my $chr = $fields[0];
		my $coor = $fields[1];
		my $g_a = $fields[2];
		my $g_b = $fields[3];
		my @geno_homo_hetero = ($fields[5],$fields[5],$fields[5],$fields[5],$fields[5],$fields[5],$fields[5],$fields[6],$fields[6],$fields[6],$fields[7],$fields[7],$fields[7]);
		my @seq_homo_hetero;
		my @most_covered_bases; #array of hashes
		my @total_coverage;
		my $ref;
		my $var;
		my $a_ref;
		my $b_ref;
		my $a_var;
		my $b_var;
		my $output_string;
		
		foreach my $coverage_position (@coverage_positions){
			my $ref_position = $coverage_position + 1;
			if ($fields[$ref_position] ne "N/A" && !$ref){
				my @ref_temp = split(/\//, $fields[$ref_position]);
				$ref = $ref_temp[0];
			}
		}
		
		if (!$ref){
			$output_string = $chr."\t".$coor."\t".$g_a."\t".$g_b."\t"."No sufficient coverage";
			for(my $i = 0; $i<@coverage_positions; $i++){
				$output_string = $output_string."\t"."No sufficient coverage";
			}
			next;
		}
		## lines(SNPs)with no sufficient sequencing data coverage on the position will be removed from the SNP file.
		
		$ref = uc($ref);
	
		my $c_ref =  ComplementaryBase($ref); 
		
		$output_string =  $chr."\t".$coor."\t".$g_a."\t".$g_b."\t".$ref;
		
		#to assign the total coverage values
		foreach my $coverage_position (@coverage_positions){
			if ($fields[$coverage_position] ne "N/A") {
				my @coverage_numbers = split (/\//, $fields[$coverage_position]);
				push @total_coverage, $coverage_numbers[0];
			}else{
				push @total_coverage,0;
			}
				
		}
		
		#to read in two most covered based on that posions for patients
		my $patient_number = 0;
		
		foreach my $coverage_position (@coverage_positions){
			my $temp_hash = {};
			for (my $i = $coverage_position + 1; $i<= $coverage_position + 4; $i++) {
				if ($fields[$i] ne "N/A") {
					my @tmp = split (/\//, $fields[$i]);
					$temp_hash->{uc($tmp[0])} = $tmp[1];
				}
			}
			
			$patient_number += 1; 
			
			if (scalar(keys %$temp_hash)  == 0) {
				print "$chr $coor: $patient_number No sufficient coverage to define any base. \n";
				push @most_covered_bases, $temp_hash;
			} elsif (scalar(keys %$temp_hash) >0 && scalar(keys %$temp_hash) <=2) {
				push @most_covered_bases, $temp_hash;
			} else {
				my @sorted = sort {$temp_hash->{$b} <=> $temp_hash->{$a}} keys %$temp_hash; 
				my $temp_hash_2 = {};
				$temp_hash_2->{$sorted[0]} = $temp_hash->{$sorted[0]}; 
				$temp_hash_2->{$sorted[1]} = $temp_hash->{$sorted[1]};
				push @most_covered_bases, $temp_hash_2;
			}
		}
		
		#determine homo/heter zygous type from the sequencing data
		for(my $i =0 ; $i <@coverage_positions; $i++) {
			if ($total_coverage[$i] == 0 ) {
				push @seq_homo_hetero, "N/A";
			} elsif ( keys %{$most_covered_bases[$i]} == 0) {
				push @seq_homo_hetero, "N/A";
			} elsif ($total_coverage[$i] > 0 && keys %{$most_covered_bases[$i]} > 0) {
				my %new_temp_hash;
				foreach my $key (keys %{$most_covered_bases[$i]}){
					#print "pbinom x is $most_covered_bases[$i]{$key}\n";
					#print "pbinom total is $total_coverage[$i]\n";
					if (pbinom($most_covered_bases[$i]{$key}, $total_coverage[$i], 0.05) > 0.95) {
						$new_temp_hash{$key} = $most_covered_bases[$i]{$key};
					}
				}
				
				$most_covered_bases[$i] = \%new_temp_hash;
				
				my %new_temp_hash_2 = %new_temp_hash;
				if(keys %new_temp_hash_2 == 0) {
					push @seq_homo_hetero, "N/A";
				} elsif (keys %new_temp_hash_2 == 1) {
					if(exists $new_temp_hash_2{$ref} || exists $new_temp_hash_2{$c_ref}) {
						push @seq_homo_hetero, "RR";
					}else {
						push @seq_homo_hetero, "VV";
					}
				} elsif (keys %new_temp_hash_2 == 2) {
					if(exists $new_temp_hash_2{$ref} || exists $new_temp_hash_2{$c_ref}) {
						if (exists $new_temp_hash_2{$ref}) {
							delete $new_temp_hash_2{$ref};
						}else {
							delete $new_temp_hash_2{$c_ref};
						}
						
						if(exists $new_temp_hash_2{$ref} || exists $new_temp_hash_2{$c_ref}) {
							push @seq_homo_hetero, "RR";
						} else {
							push @seq_homo_hetero, "RV";
						}
					} else {
						my @keys = keys %new_temp_hash_2;
						if ($keys[0] ne ComplementaryBase($keys[1])) {
							push @seq_homo_hetero, "RV";
							print "$chr $coor: possible error for reference base at postion.\n";
						}else {
							push @seq_homo_hetero, "VV";
						}
					}
				} else {
					print "$chr $coor :";
					print "new_temp_hash has invalid elements number:";
					print keys %new_temp_hash_2;
					print "\n";
				}
			}
		}
	
		#compare A B bases to ref
		
		if (CompareAwithB($g_a,$ref) eq "No Match"){
			$a_ref = "N/A";
		} else {
			if (CompareAwithB($g_a,$ref) eq "A=B") {
				$a_ref = "A=Ref";
			}else {
				$a_ref = "A=C_Ref";
			}	
		}	
	 	
	 	if (CompareAwithB($g_b,$ref) eq "No Match"){
			$b_ref = "N/A";
		} else {
			if (CompareAwithB($g_b,$ref) eq "A=B") {
				$b_ref = "B=Ref";
			}else {
				$b_ref = "B=C_Ref";
			}	
		}
		
		if (CompareAwithB($g_b,$ref) eq "No Match" && CompareAwithB($g_a,$ref) eq "No Match"){
			print "$chr $coor: What a Ref!!!!!\n";
		}
		
		######################################
		##### determine if the geno chip data is consistant with sequencing data
		###########################################################################
		##### and determine number of true positives, true negatives
		##### ,false positives and false negatives (take geno chip data as reality).
		##### This is used calculate the sensitivity and specificity of Sequencing data to detect variants
		######################################
		
	
		
		for(my $i =0 ; $i <@coverage_positions; $i++) {
		
			if ($geno_homo_hetero[$i] eq "no call"  || keys %{$most_covered_bases[$i]} == 0 ){ 
			# if nocall in genotyping data for the patient or there's no base is confirmed on the position from the seqencing data
				if ($geno_homo_hetero[$i] eq "no call" ) {
					$output_string = $output_string."\t"."no call";
				} else {
					$output_string = $output_string."\t"."No sufficient coverage";
				}
				next;
			} elsif (keys %{$most_covered_bases[$i]} == 1) {
			# if one base is confirmed on the position from the seqencing data
				if ($geno_homo_hetero[$i] eq "AA" || $geno_homo_hetero[$i] eq "BB"  ) {
				#geno typing data situations
					if ($a_ref ne "N/A" && $b_ref eq "N/A" ) { 
					# if Allele A is equal to ref or complemtary ref
						if ($geno_homo_hetero[$i] eq "AA") { # AA 
							if ($a_ref  eq "A=Ref"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ComplementaryBase($g_a)}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else { #BB
							if ($a_ref  eq "A=Ref") {
								if (exists $most_covered_bases[$i]{$g_b}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$true_positives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if (exists $most_covered_bases[$i]{$g_a}) {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_negatives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$false_positives[$i] += 1;
										}
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ ComplementaryBase($g_b)}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$true_positives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if (exists $most_covered_bases[$i]{ComplementaryBase($g_a)}) {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_negatives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$false_positives[$i] += 1;
										}
									}
								}
							}
						}
					} elsif ($a_ref eq "N/A" && $b_ref ne "N/A" ) {
					# if Allele B is equal to ref or complemtary ref
						if  ($geno_homo_hetero[$i] eq "AA") { #AA
							if ($b_ref  eq "B=Ref"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$true_positives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if (exists $most_covered_bases[$i]{$g_b}) {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_negatives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$false_positives[$i] += 1;
										}
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ ComplementaryBase($g_a)}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$true_positives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if (exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_negatives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$false_positives[$i] += 1;
										}
									}
								}
							}
						} else { #BB
							if ($b_ref  eq "B=Ref"){
								if (exists $most_covered_bases[$i]{$g_b}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ ComplementaryBase($g_b)}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						}					
					} else { #Either Allele A or Allele B is either equal or complementary to ref
					#treat Allele A and Allele B are non related, one stands for Ref and the other one stands for Var
						if($a_ref eq "A=Ref"){
							if  ($geno_homo_hetero[$i] eq "AA"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							} else {#BB
								if (exists $most_covered_bases[$i]{$g_b}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$true_positives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if(exists $most_covered_bases[$i]{$g_a}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_negatives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$false_positives[$i] += 1;
										}
									}
								}
							}
						}elsif($b_ref eq "B=Ref"){
							if  ($geno_homo_hetero[$i] eq "AA"){
								if (exists $most_covered_bases[$i]{$g_a}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$true_positives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if(exists $most_covered_bases[$i]{$g_b}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_negatives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$false_positives[$i] += 1;
										}
									}
								}
							} else {#BB
								if (exists $most_covered_bases[$i]{$g_b}) {
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									$output_string = $output_string."\t"."Inconsistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else {
							##########################################################################
							# if both Allele A and Allele B  are NON related to ref or complemtary ref
							#rare but possible
							##but this does not necessrayly mean that var from sequencing data is not confirmed by chip data
							###require further code here. It's not right to treat the situation as N/A
							###########################################################################
							###########################################################################
							#changed code - 16/02/2011
							if(exists $most_covered_bases[$i]{$ref} ) {
								$output_string = $output_string."\t"."Inconsistent";
								if($chr ne "chrX" && $chr ne "chrY"){
									$false_negatives[$i] += 1;
									$false_negatives[$i] += 1;
								}
							} else {
								if ($most_covered_bases[$i]{$g_a} && $geno_homo_hetero[$i] eq "AA"){
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$true_positives[$i] += 1;
									}
								}elsif($most_covered_bases[$i]{$g_b} && $geno_homo_hetero[$i] eq "BB"){
									$output_string = $output_string."\t"."Consistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$true_positives[$i] += 1;
									}
								}else{
									$output_string = $output_string."\t"."Inconsistent";
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						}
					}
				} else { # "AB" appears on geno chip
					$output_string = $output_string."\t"."Inconsistent";
					if ($a_ref ne "N/A" && $b_ref eq "N/A" ){
						if ($a_ref  eq "A=Ref") {
							if (exists $most_covered_bases[$i]{$g_b}) {
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$false_positives[$i] += 1;
								}
							} else{
								if (exists $most_covered_bases[$i]{$ref}) {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else {
							if (exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$false_positives[$i] += 1;
								}
							} else{
								if (exists $most_covered_bases[$i]{$ref}) {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						}
					} elsif ($b_ref ne "N/A" && $a_ref eq "N/A") {
						if ($b_ref  eq "B=Ref") {
							if (exists $most_covered_bases[$i]{$g_a}) {
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$false_positives[$i] += 1;
								}
							} else{
								if (exists $most_covered_bases[$i]{$ref}) {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else {
							if (exists $most_covered_bases[$i]{ComplementaryBase($g_a)}) {
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$false_positives[$i] += 1;
								}
							} else{
								if (exists $most_covered_bases[$i]{$ref}) {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_negatives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						}
					} else {
						if($a_ref ne "N/A"){
							if (exists $most_covered_bases[$i]{$ref} || exists $most_covered_bases[$i]{ComplementaryBase($ref)} ){
								if($chr ne "chrX" && $chr ne "chrY"){
									$false_negatives[$i] += 1;
									$true_negatives[$i] += 1;
								}
							} else {
								if($chr ne "chrX" && $chr ne "chrY"){
									$false_positives[$i] += 1;
									$false_positives[$i] += 1;
								}
							}
						}else {
							if (exists $most_covered_bases[$i]{$ref} || exists $most_covered_bases[$i]{ComplementaryBase($ref)} ){
								if($chr ne "chrX" && $chr ne "chrY"){
									$false_negatives[$i] += 1;
									$true_negatives[$i] += 1;
								}
							}elsif (exists $most_covered_bases[$i]{$g_a} || exists $most_covered_bases[$i]{$g_b} ){
								if($chr ne "chrX" && $chr ne "chrY"){
									$false_positives[$i] += 1;
									$true_positives[$i] += 1;
								}
							} else {
								if($chr ne "chrX" && $chr ne "chrY"){
									$false_positives[$i] += 1;
									$false_positives[$i] += 1;
								}
							}
						}
					}
				}
			} elsif (keys %{$most_covered_bases[$i]} == 2) {
				if ($geno_homo_hetero[$i] eq "AB") {
					if($a_ref ne "N/A" && $b_ref eq "N/A" ){
						if($a_ref  eq "A=Ref"){
							if(exists $most_covered_bases[$i]{$g_a} && exists $most_covered_bases[$i]{$g_b}) {
								$output_string = $output_string."\t"."Consistent";
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$true_negatives[$i] += 1;
								}
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{$g_a} ||  exists $most_covered_bases[$i]{$g_b}) {
									if(exists $most_covered_bases[$i]{$g_a}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_negatives[$i] += 1;
										}
									}else{
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								}else{
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else {
							if(exists $most_covered_bases[$i]{ComplementaryBase($g_a)} && exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
								$output_string = $output_string."\t"."Consistent";
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$true_negatives[$i] += 1;
								}
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{ComplementaryBase($g_a)} ||  exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
									if(exists $most_covered_bases[$i]{ComplementaryBase($g_a)}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_negatives[$i] += 1;
										}
									}else{
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						}
					} elsif ($a_ref eq "N/A" && $b_ref ne "N/A" ) {
						if($b_ref  eq "B=Ref"){
							if(exists $most_covered_bases[$i]{$g_a} && exists $most_covered_bases[$i]{$g_b}) {
								$output_string = $output_string."\t"."Consistent";
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$true_negatives[$i] += 1;
								}
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{$g_a} ||  exists $most_covered_bases[$i]{$g_b}) {
									if(exists $most_covered_bases[$i]{$g_b}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_negatives[$i] += 1;
										}
									}else{
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else {
							if(exists $most_covered_bases[$i]{ComplementaryBase($g_a)} && exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
								$output_string = $output_string."\t"."Consistent";
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$true_negatives[$i] += 1;
								}
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{ComplementaryBase($g_a)} ||  exists $most_covered_bases[$i]{ComplementaryBase($g_b)}) {
									if(exists $most_covered_bases[$i]{ComplementaryBase($g_b)}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_negatives[$i] += 1;
										}
									}else{
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						}
					}else {
						if($a_ref eq "A=Ref"){
							if(exists $most_covered_bases[$i]{$g_a} && exists $most_covered_bases[$i]{$g_b}) {
								$output_string = $output_string."\t"."Consistent";
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$true_negatives[$i] += 1;
								}
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{$g_a} ||  exists $most_covered_bases[$i]{$g_b}) {
									if(exists $most_covered_bases[$i]{$g_a}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_negatives[$i] += 1;
										}
									}else{
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						}elsif($b_ref eq "B=Ref"){
							if(exists $most_covered_bases[$i]{$g_a} && exists $most_covered_bases[$i]{$g_b}) {
								$output_string = $output_string."\t"."Consistent";
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$true_negatives[$i] += 1;
								}
							} else {
								$output_string = $output_string."\t"."Inconsistent";
								if ( exists $most_covered_bases[$i]{$g_a} ||  exists $most_covered_bases[$i]{$g_b}) {
									if(exists $most_covered_bases[$i]{$g_b}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_negatives[$i] += 1;
										}
									}else{
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								} else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else {
							# if both Allele A and Allele B  are NON related to ref or complemtary ref
							#rare but possible
							$output_string = $output_string."\t"."N/A2222";
							############################### 17/02/2011 ################################# Done here ###############
	
							if ( exists $most_covered_bases[$i]{$g_a} &&  exists $most_covered_bases[$i]{$g_b}) {
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$true_positives[$i] += 1;
								}
							} else {
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$false_negatives[$i] += 1;
								}
							}
							############################### 17/02/2011 ################################# Done here ###############
						}
					}				
				} else {
					$output_string = $output_string."\t"."Inconsistent";
					
					######################################################################
					######################################################################
					####   hard bit											 #############
					######################################################################
					######################################################################
					
					if ($a_ref ne "N/A" && $b_ref eq "N/A" ) {
						if ($geno_homo_hetero[$i] eq "AA"){
							if ($a_ref  eq "A=Ref") {
								if (exists $most_covered_bases[$i]{$g_a}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								}else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ComplementaryBase($g_a)}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								}else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else {#BB
							if ($a_ref  eq "A=Ref") {
								if (exists $most_covered_bases[$i]{$g_b} && exists $most_covered_bases[$i]{$g_a}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$false_negatives[$i] += 1;
									}
								}else{
									if(exists $most_covered_bases[$i]{$g_b}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}elsif(exists $most_covered_bases[$i]{$g_a}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ComplementaryBase($g_b)} && exists $most_covered_bases[$i]{ComplementaryBase($g_a)}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$false_negatives[$i] += 1;
									}
								}else{
									if(exists $most_covered_bases[$i]{ComplementaryBase($g_b)}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}elsif(exists $most_covered_bases[$i]{ComplementaryBase($g_a)}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								}
							}
						}
					} elsif ( $a_ref eq "N/A" && $b_ref ne "N/A" ){
						if ($geno_homo_hetero[$i] eq "BB"){
							if ($b_ref  eq "B=Ref") {
								if (exists $most_covered_bases[$i]{$g_b}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								}else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ComplementaryBase($g_b)}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								}else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							}
						} else {#AA
							if ($b_ref  eq "B=Ref") {
								if (exists $most_covered_bases[$i]{$g_b} && exists $most_covered_bases[$i]{$g_a}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$false_negatives[$i] += 1;
									}
								}else{
									if(exists $most_covered_bases[$i]{$g_a}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}elsif(exists $most_covered_bases[$i]{$g_b}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{ComplementaryBase($g_b)} && exists $most_covered_bases[$i]{ComplementaryBase($g_a)}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$false_negatives[$i] += 1;
									}
								}else{
									if(exists $most_covered_bases[$i]{ComplementaryBase($g_a)}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}elsif(exists $most_covered_bases[$i]{ComplementaryBase($g_b)}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								}
							}
						}
					} else { # if both Allele A and Allele B are related to ref
						if ($a_ref  eq "A=Ref") {# if both Allele A and Allele B are related to ref
							if ($geno_homo_hetero[$i] eq "AA") {
								if (exists $most_covered_bases[$i]{$g_a}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								}else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{$g_b} && exists $most_covered_bases[$i]{$g_a}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$false_negatives[$i] += 1;
									}
								}else{
									if(exists $most_covered_bases[$i]{$g_b}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}elsif(exists $most_covered_bases[$i]{$g_a}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								}
							}
						} elsif ($b_ref  eq "B=Ref") {# if both Allele A and Allele B are related to ref
							if ($geno_homo_hetero[$i] eq "BB") {
								if (exists $most_covered_bases[$i]{$g_b}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$true_negatives[$i] += 1;
									}
								}else {
									if($chr ne "chrX" && $chr ne "chrY"){
										$false_positives[$i] += 1;
										$false_positives[$i] += 1;
									}
								}
							} else {
								if (exists $most_covered_bases[$i]{$g_b} && exists $most_covered_bases[$i]{$g_a}){
									if($chr ne "chrX" && $chr ne "chrY"){
										$true_positives[$i] += 1;
										$false_negatives[$i] += 1;
									}
								}else{
									if(exists $most_covered_bases[$i]{$g_a}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$true_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}elsif(exists $most_covered_bases[$i]{$g_b}){
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$false_negatives[$i] += 1;
										}
									} else {
										if($chr ne "chrX" && $chr ne "chrY"){
											$false_positives[$i] += 1;
											$true_positives[$i] += 1;
										}
									}
								}
							}
						}elsif( exists $most_covered_bases[$i]{$g_a} || exists $most_covered_bases[$i]{$g_b}) {
							# if both Allele A and Allele B are NON related to ref
							if (exists $most_covered_bases[$i]{$ref}){
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$false_negatives[$i] += 1;
								}
							}else{
								if($chr ne "chrX" && $chr ne "chrY"){
									$true_positives[$i] += 1;
									$true_positives[$i] += 1;
								}
							}
						} else {
							if($chr ne "chrX" && $chr ne "chrY"){
								$false_positives[$i] += 1;
								$false_negatives[$i] += 1;
							}
						}
					}
				}
			}
		}
		print OUTPUT $output_string."\n";
	}
	
	close INPUT;
	close OUTPUT;
	
	for(my $j =0 ; $j <@coverage_positions; $j++) {
		print "For patient $j :\n";
		print "\tTrue Positives = ";
		print $true_positives[$j];
		print "\n";
		print "\tFalse Positives = ";
		print $false_positives[$j];
		print "\n";
		print "\tTrue Negatives = ";
		print $true_negatives[$j];
		print "\n";
		print "\tFalse Negatives = ";
		print $false_negatives[$j];
		print "\n";
		print "\n";
		print "\tSensitivity of Exome sequencing for Genotyping quality in autosomes is ";
		print $true_positives[$j]/($true_positives[$j] + $false_negatives[$j]);
		print "\n";
		print "\tSpecificity of Genotyping quality in autosomes is ";
		print $true_negatives[$j]/($true_negatives[$j] + $false_positives[$j]);
		print "\n";
		print "\tFalse Discovery Rate of Genotyping quality in autosomes is ";
		print $false_positives[$j]/($true_positives[$j] + $false_positives[$j]);
		print "\n";
		print "\n";
		print "\n";
	}
	
}


sub ComplementaryBase {
	my($x) = @_;
	my $c_x = $x;
	$c_x =~ tr/[A,a,T,t,G,g,C,c]/[T,t,A,a,C,c,G,g]/;
	return $c_x;
}

sub CompareAwithB {
	my ($x,$y) = @_;
	if ($x eq  $y) {
		return "A=B";
	}elsif ($x eq ComplementaryBase($y)) {
		return "A=C_B";
	}else {
		return "No Match";
	}
}



